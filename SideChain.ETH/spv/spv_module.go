package spv

import (
	"bytes"
	"encoding/hex"
	"errors"
	"fmt"
	"github.com/elastos/Elastos.ELA.SPV/bloom"
	spv "github.com/elastos/Elastos.ELA.SPV/interface"
	ethCommon "github.com/elastos/Elastos.ELA.SideChain.ETH/common"
	"github.com/elastos/Elastos.ELA.SideChain.ETH/crypto"
	"github.com/elastos/Elastos.ELA.SideChain/types"
	"github.com/elastos/Elastos.ELA/common"
	core "github.com/elastos/Elastos.ELA/core/types"
	com "github.com/elastos/Elastos.ELA.SideChain.ETH/common"
	"github.com/syndtr/goleveldb/leveldb"
	"path/filepath"
	"strings"
	"time"
)

const (
	minConnections = 8
	maxConnections = 125
)

var dataDir = "./"

type Config struct {
	// DataDir is the data path to store db files peer addresses etc.
	DataDir string

	// The magic number that specify which network to connect.
	Magic uint32

	// The foundation address of the genesis block, which is different between
	// MainNet, TestNet, RegNet etc.
	Foundation string

	// The public seed peers addresses.
	SeedList []string

	// NodePort is the default port for public peers provide services.
	DefaultPort uint16

	// GenesisAddress is the address generated by the side chain genesis block.
	GenesisAddress string
}

type Service struct {
	spv.DPOSSPVService
}

//func NewService(cfg *Config) (*Service, error) {
//	chainParams := config.DefaultParams.TestNet()
//	spvCfg := spv.DPOSConfig{
//		Config: spv.Config{
//			DataDir:        cfg.DataDir,
//			Magic:          chainParams.Magic,
//			Foundation:     "8ZNizBf4KhhPjeJRGpox6rPcHE5Np6tFx3",
//			SeedList:       chainParams.SeedList,
//			DefaultPort:    chainParams.DefaultPort,
//			MinOutbound:    8,
//			MaxConnections: 100,
//		},
//		ChainParams: chainParams,
//		//可以有回调机制，在任何arbiters发生改变的时候，将arbiters信息推过来（需要实现该接口）
//	}
//	dataDir = cfg.DataDir
//	initLog(cfg.DataDir)
//
//	service, err := spv.NewDPOSSPVService(&spvCfg, signal.NewInterrupt().C)
//	if err != nil {
//		return nil, err
//	}
//
//	err = service.RegisterTransactionListener(&listener{
//		address: cfg.GenesisAddress,
//		service: service,
//	})
//
//	if err != nil {
//		return nil, err
//	}
//
//	spvService = &Service{ service}
//	return &Service{DPOSSPVService: service}, nil
//}

func (s *Service) VerifyTransaction(tx *types.Transaction) error {
	payload, ok := tx.Payload.(*types.PayloadRechargeToSideChain)
	if !ok {
		return errors.New("[VerifyTransaction] Invalid payload core.PayloadRechargeToSideChain")
	}

	switch tx.PayloadVersion {
	case types.RechargeToSideChainPayloadVersion0:

		proof := new(bloom.MerkleProof)
		mainChainTransaction := new(core.Transaction)

		reader := bytes.NewReader(payload.MerkleProof)
		if err := proof.Deserialize(reader); err != nil {
			return errors.New("[VerifyTransaction] RechargeToSideChain payload deserialize failed")
		}

		reader = bytes.NewReader(payload.MainChainTransaction)
		if err := mainChainTransaction.Deserialize(reader); err != nil {
			return errors.New("[VerifyTransaction] RechargeToSideChain mainChainTransaction deserialize failed")
		}

		if err := s.DPOSSPVService.VerifyTransaction(*proof, *mainChainTransaction); err != nil {
			return errors.New("[VerifyTransaction] SPV module verify transaction failed.")
		}

	case types.RechargeToSideChainPayloadVersion1:

		_, err := s.GetTransaction(&payload.MainChainTransactionHash)
		if err != nil {
			return errors.New("[VerifyTransaction] Main chain transaction not found")
		}

	default:
		return errors.New("[VerifyTransaction] invalid payload version.")
	}

	return nil
}

func (s *Service) VerifyElaHeader(hash *common.Uint256) error {
	blockChain := s.HeaderStore()
	_, err := blockChain.Get(hash)
	if err != nil {
		return errors.New("[VerifyElaHeader] Verify ela header failed.")
	}
	return nil
}

type listener struct {
	address string
	service spv.DPOSSPVService
}

func (l *listener) Address() string {
	return l.address
}

func (l *listener) Type() core.TxType {
	return core.TransferCrossChainAsset
}

func (l *listener) Flags() uint64 {
	return spv.FlagNotifyInSyncing
}

func (l *listener) Notify(id common.Uint256, proof bloom.MerkleProof, tx core.Transaction) {
	// Submit transaction receipt
	fmt.Println(" ")
	fmt.Println(" ")
	fmt.Println("========================================================================================")
	fmt.Println("mainchain transaction info")
	fmt.Println("----------------------------------------------------------------------------------------")
	fmt.Println(string(tx.String()))
	fmt.Println("----------------------------------------------------------------------------------------")
	fmt.Println(" ")
	savePayloadInfo(tx)
	defer l.service.SubmitTransactionReceipt(id, tx.Hash())
}

func savePayloadInfo(elaTx core.Transaction) error {
	db, err := leveldb.OpenFile(filepath.Join(dataDir, "spv_transaction_info.db"), nil)
	if err != nil {
		fmt.Println(err)
	}
	defer db.Close()
	err = db.Put([]byte(elaTx.Hash().String()), []byte(hex.EncodeToString(elaTx.Payload.Data(elaTx.PayloadVersion))), nil)

	if err != nil {
		fmt.Println(err)
	}
	return nil
}

func FindPayloadByTransactionHash(transactionHash string) string {
	if transactionHash == "" {
		return "0"
	}

	transactionHash = strings.Replace(transactionHash, "0x", "", 1)
	db, err := leveldb.OpenFile(filepath.Join(dataDir, "spv_transaction_info.db"), nil)
	if err != nil {
		fmt.Println(err)
		return "0"
	}
	defer db.Close()

	v, err := db.Get([]byte(transactionHash), nil)

	if err != nil {
		fmt.Println(err)
		return "0"
	}

	return string(v)

}

// Get Ela Chain Height 
func GetElaChainHeight() uint32 {
	var elaHeight uint32 = 0
	if spvService == nil || spvService.DPOSSPVService == nil {
		fmt.Println("spv service initiation does not finish yet !")
	} else {
		elaHeight = spvService.DPOSSPVService.GetHeight()
	}
	return elaHeight
}

// Until Get Ela Chain Height 
func UntilGetElaChainHeight() uint32 {
	for {
		if elaHeight := GetElaChainHeight(); elaHeight != 0  {
			return elaHeight
		}
		fmt.Println("can not get elas height, because ela height interface has no any response !")
		time.Sleep(time.Millisecond*1000)
	}
}

// Determine whether an address is an arbiter 
func AddrIsArbiter(address ethCommon.Address) int8 {
	if spvService == nil || spvService.DPOSSPVService == nil {
		fmt.Println("spv service initiation does not finish yet !")
	} else {
		arbiters := spvService.DPOSSPVService.GetProducersByHeight(spvService.DPOSSPVService.GetHeight())
		for _, arbiter := range arbiters {
			publicKey, convertErr := crypto.UnmarshalPubkey(arbiter)
			if convertErr == nil {
				if abiterAddress := crypto.PubkeyToAddress(*publicKey); abiterAddress == address {
					return 1
				}
			}
		}
	}
	return 0
}

// Determine whether an address is an arbiter
func AddrIsArbiterWithElaHeight(address ethCommon.Address, elaHeight uint32) int8 {
	if spvService == nil || spvService.DPOSSPVService == nil {
		fmt.Println("spv service initiation does not finish yet !")
	} else {
		arbiters := spvService.DPOSSPVService.GetProducersByHeight(elaHeight)
		for _, arbiter := range arbiters {
			publicKey, convertErr := crypto.UnmarshalPubkey(arbiter)
			if convertErr == nil {
				if abiterAddress := crypto.PubkeyToAddress(*publicKey); abiterAddress == address {
					return 1
				}
			}
		}
	}
	return 0
}

func GetCurrentProducers() [][]byte {
	var arbiters [][]byte
	if spvService == nil || spvService.DPOSSPVService == nil {
		fmt.Println("spv service initiation does not finish yet !")
	} else {
		arbiters := spvService.DPOSSPVService.GetProducersByHeight(GetCurrentElaHeight())
		fmt.Println("---------------------------------------------------------------")
		fmt.Println(arbiters)
	}

	return arbiters
}

func GetCurrentElaHeight() uint32 {
	var height uint32
	if spvService == nil || spvService.DPOSSPVService == nil {
		fmt.Println("spv service initiation does not finish yet !")
	} else {
		height = spvService.DPOSSPVService.GetHeight()
		fmt.Println("----GetCurrentElaHeight-----------------------------------------------------------")
		fmt.Println(height)
	}

	return height
}

func GetSubContractAddress() com.Address {
	return com.HexToAddress("0xc11790E64046f1892b6e26cE010E31958b11639F")
}

func GetProducersByHeight(height uint32) [][]byte {
	var arbiters [][]byte

	if spvService == nil || spvService.DPOSSPVService == nil {
		fmt.Println("spv service initiation does not finish yet !")
	} else {
		arbiters := spvService.DPOSSPVService.GetProducersByHeight(height)
		fmt.Println("---------------------------------------------------------------")
		fmt.Println(arbiters)
	}
	return arbiters
}

//Service
var spvService *Service

